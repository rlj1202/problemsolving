# 누적합

역원이 존재하는 연산에 대해서만 가능.

예) 구간 합

        0   1   2   3   4   5   6   7
수열 = {1,  2,  3,  4,  5,  6,  7,  8, ...}
합   = {1,  3,  6, 10, 15, 21, 28, 36, ...}

2 부터 7까지의 합 = 36 - 3 = 33


# sparse tree
역원이 존재하지 않는 최대, 최소 연산에 대한 빠른 구간 연산을 위한 data structure


```
   0                 1                 ...
0 [a_0_0             a_0_1             ...] // 길이가 2^0인 구간에서의 최대값
1 [max(a_0_0, a_0_1) max(a_0_1, a_0_2) ...] // 길이가 2^1인 구간에서의 최대값
2 [max(a_1_0, a_1_3) max(a_1_1, a_1_4) ...] // 길이가 2^2인 구간에서의 최대값
3 [                  ...                  ] // 길이가 2^3인 구간에서의 최대값
...
```



## 트리 구성하기

int arr[N];
int max[log N][N];

for (int i = 0; i < N; i++) {
	max[0][i] = arr[i];
}

for (int i = 1; i < log N; i++) {
	for (int j = 0; j < N; j++) {
		max[i][j] = max(
			max[i - 1][j],
			max[i - 1][min(N - 1, j + 2^(i + 1))]
		);
	}
}

### 시간복잡도

O(N + N log N) = O(N log N)

## 어떻게 작동하는가?

[i, j] 구간에서의 최대값을 어떻게 구할것인가?


